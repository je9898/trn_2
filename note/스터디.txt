1차
public privat protected defult
	-> 접근 제한자
	-> public : 어디서든
	-> default : 같은 패키지
	-> privat : 내꺼에서만(중괄호 범위)
	-> protected : 같은 패키지, 자식 클래스

static 
	-> 메모리에 올려둠 (사용 안해도 메모리 잡아먹어)
	-> static 안쓰면 사용 할 떄 메모리에 올려 
	-> 실핼할때 메모리에 바로 올림
	-> 프로그램 종료까지 계속 올라가있음.
	-> 남발하면 메모리 낭비.
	-> 자주 사용하는 상수에는 쓰면 메모리면에서 더 좋음.
	-> 클래스 명으로 접근 가능.
	-> 메모리보단 공유의 목적으로 사용.
	
void
	-> return값 있냐 없냐
	-> 안쓰면 자료형 써줘야해, return값 있어야해.
	
private void MethodeName1(){
	요놈 상위 클래스에서만 사용할수 있으며, 리턴값이 없는 함수.
}

int MethodeName2(){
	같은 패키치 내에서 사용할수 있으며, int형 리턴값 주는 함수.
}

public static String MethodeName3(){
	어디서든 사용할수 있으며, 인스턴스 없이 클래스명으로 접근 가능하며, String형 리턴값 주는 함수.
}


전역과 지역 (유효범위)
	this 중요성
	전역 남발하지마라 객체 쪼개서 쓰자 
	파라메터로 받아와야지 전역에 의존하면 전역변수에 종속되어 재활욜하기 어렵다.







2차

	
상속
	-> class 생성할때 부모class extends 
	-> class c1 extends c2	
		-> c1클래스 만들건데 c2상속받을거야
	-> 코드 중복제거, 근데 부모클래스 바뀌면 자식도 영향받잖어..

인터페이스
	abstract methodeName(); 
	-> methodeName이름의 추상 메소드를 만들겠다.

	기본 class에서 메소드(public, 추상, 리턴값없는) 생성
	-> public abstract void methodeName();
	인터페이스에서 동일한놈 생성
	-> void methodeName();
	-> 사용자 편의성을 위해 생략가능 
	-> 기존 default는 못써? => 응 못써, 왜? 몰라 찾아보자
	-> java8.0부터 default,static 지원. 여기 default와 접근제어자 default는 다른놈이다 ㅋㅋ
		자바8부터 인터페이스에서 디폴트 메소드 선언기능이 추가됐네요.
		default 키워드 넣어서 메소드 선언하고 안에 내용까지 입력할 수 있게 됐어요.
		그러면 구현체가 있으니까 궂이 하위클래스에서 그 메소드를 오버라이드할 필요가 없어지겠네요.
		default 키워드로 된 메소드는 따로 오버라이딩하지 않으면 기본적으로 구현 된 방식으로 동작한다네요.
		
	인터페이스에서는 기본적으로 상속이라고 보면됨
	-> 근데 강제성이 있냐 없냐 차이.
	
오버라이딩
	-> 상속받은 메소드 등.. 재정의
	-> 필요없는건 거절한다.
	-> 재정의 = 덮어쓰기 = 오버라이딩 ㅋㅋ
	
	
	생성자
	-> new 
	-> class이름과 동일한 methode 만들면 "생성자" 라고 부른다.
	-> 없으면 자바 내부적으로 만들고, 있으면 우선순위 ㅇㅋ?
	-> 생성자 메소드는 제일 우선순위로 실행된다.
	
3.
class 구조에 대한 이해.
	함수 호출 변수 호출 상속받고 부모꺼사용 등...
	여기서 꺼내고 저기서 꺼내고 
	
new 생성자